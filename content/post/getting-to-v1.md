+++
categories = [
  "Programming",
]
tags = [
  "programming",
  "hackMH"
]
date = "2016-10-24T02:13:51Z"
title = "Getting to v1: Shoutout and Text Support"
+++

Other the past couple of months, I've had the privilege of working
with some other talented developers on finishing
two [hackMH](http://hackmh.com/) projects we've been working on for a while:
[shoutout](https://shoutout.hackmh.com) and
[text-support](https://text-support.hackmh.com). As a side note,
[shoutout](https://github.com/hackmh/shoutout) is a Slack plugin for creating
more positive and appreciative communities, while
[text-support](https://github.com/hackmh/text-support) is an automated text bot
for assisting individuals supporting friends. If either of those sound
interesting, there's still a bunch of 1.1 features (see below) we'd love help
building. Just click on the previous links for more info re contributing.

One of these projects, *shoutout*, was a long time coming (i.e. over a year from
first commit to closing the final issue on the v1 milestone). The other,
*text-support*, was quicker (i.e. around three months). Both were developed
under different circumstances and with different technologies. We built
*shoutout* with Rails, a technology I was less and less familiar with over the
course of development, as both of us worked to finish thesis during our senior
year at Williams. In contrast, *text-support* was built the summer after we
graduated, with Python and Flask, technologies we'd be using at our upcoming
jobs. Still, one main lesson applied to both: the importance of defining ahead
of time what it means to reach version 1.0.

For these projects, they were purely on the side. We built them to learn and with
the hope that it may help some people improve their mental health. As such, it
was tempting to never define a single milestone where the project would be "ready"
for others to use. Moreover, the project would always be lingering in
"unfinished" status, where it felt like exploring new ideas and concepts would
lead to casting these projects aside before they reached any tangible endpoint.
We avoided this by (either mentally or in Github issues) defining two categories
of issues/features/enhancements: 1.0 and 1.1. Anything necessary for the project
to function was in 1.0. Anything we thought would be cool or a marginal
improvement went in 1.1. Then, I chose a weekend for each project and committed
to coding and closing issues until we reached 1.0, at once point I would
consider both these projects "done". Of course we could go back and make the 1.1
changes as we desired. But we also wouldn't feel guilty moving onto other
projects and learning opportunities.

Overall, this method of dividing issues helped provide some needed finality to
the otherwise infinite process of improving software.
